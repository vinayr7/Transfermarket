#Bibliotheken laden

import pandas as pd
import numpy as np
import glob
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score
from matplotlib.lines import Line2D
from matplotlib.patches import Patch
import warnings

# Warnungen unterdr√ºcken f√ºr saubere Ausgabe
warnings.filterwarnings('ignore')

# Stile f√ºr Seaborn-Visualisierungen
sns.set_theme(style="whitegrid")
print("‚úÖ Alle Bibliotheken geladen!")

# Pfad zu den CSV-Dateien
csv_folder = r"C:\Users\vinay\Desktop\Uni\Semester 6\Data Science in Practice\Project\csv files"
all_files = glob.glob(csv_folder + "/*.csv")

# Lade alle CSV-Dateien und kombiniere sie
data = pd.concat([pd.read_csv(f) for f in all_files], ignore_index=True)

# Spielernamen f√ºr Suche vorbereiten
data["player_name"] = data["player_name"].str.lower()
print("‚úÖ Daten geladen. Verf√ºgbare Spalten:", data.columns.tolist())

# ---------- FEHLENDE WERTE BEHANDELN ----------
# L√∂sche Zeilen mit fehlenden Werten in Schl√ºsselspalten
data = data.dropna(subset=["goals", "assists", "minutes_played"])

# ---------- ECHTE MARKTWERTE VS. K√úNSTLICHE FORMEL ----------
# üéØ PR√ÑSENTATIONS-ABSCHNITT 1: DATENGRUNDLAGE UND ZIELVARIABLEN

print("\nüéØ MARKTWERT-ANALYSE: VON K√úNSTLICH ZU REAL")
print("=" * 60)

# Option A: K√ºnstliche Formel (f√ºr Vergleichszwecke beibehalten)
data["verdienter_marktwert_formel"] = (
    data["goals"] * 1_000_000 
    + data["assists"] * 500_000 
    - data["yellow_cards"] * 200_000 
    - data["red_cards"] * 1_000_000
)

# Option B: Echte Marktwerte aus dem Dataset nutzen
# F√ºr ML-Training verwenden wir ECHTE Marktwerte!
marktwert_verf√ºgbar = data["market_value_in_eur"].count()
print(f"‚úÖ Echte Marktwerte verf√ºgbar: {marktwert_verf√ºgbar:,} Spieler")
print(f"‚úÖ Performance-Daten verf√ºgbar: {len(data):,} Eintr√§ge")

# Hauptzielvariable f√ºr ML: Echte Marktwerte
data["zielvariable_ml"] = data["market_value_in_eur"]

# ---------- ERWEITERTE FEATURE-ENGINEERING ----------
# üéØ PR√ÑSENTATIONS-ABSCHNITT 2: INTELLIGENTE FEATURE-ERSTELLUNG

print("\nüîß ERWEITERTE FEATURE-ENGINEERING...")

# Basis-Effizienz-Metriken
data["goal_efficiency"] = data["goals"] / data["minutes_played"].replace(0, 1)
data["assist_efficiency"] = data["assists"] / data["minutes_played"].replace(0, 1)

# Disziplin-Score (weniger Karten = besser)
data["discipline_score"] = 1 / (1 + data["yellow_cards"] + data["red_cards"] * 3)

# Gesamtleistungs-Index
data["performance_index"] = (
    data["goals"] * 2 + 
    data["assists"] * 1.5 + 
    data["minutes_played"] / 90 * 0.1 -
    data["yellow_cards"] * 0.1 - 
    data["red_cards"] * 0.5
)

print("‚úÖ Features erstellt: goal_efficiency, assist_efficiency, discipline_score, performance_index")

# ---------- MARKTWERT-VERTEILUNGEN VERGLEICHEN ----------
# üéØ PR√ÑSENTATIONS-ABSCHNITT 3: K√úNSTLICH VS. ECHTE MARKTWERTE

print("\nüìä MARKTWERT-VERTEILUNGEN VISUALISIEREN...")

# Erstelle Subplots f√ºr Vergleich
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. K√ºnstliche Formel-Verteilung
axes[0,0].hist(data["verdienter_marktwert_formel"], bins=50, alpha=0.7, color='skyblue', edgecolor='black')
axes[0,0].set_title("Verteilung: K√ºnstliche Marktwert-Formel")
axes[0,0].set_xlabel("Marktwert (‚Ç¨)")
axes[0,0].set_ylabel("H√§ufigkeit")

# 2. Echte Marktwert-Verteilung (nur verf√ºgbare Daten)
echte_marktwerte = data.dropna(subset=["market_value_in_eur"])
if len(echte_marktwerte) > 0:
    axes[0,1].hist(echte_marktwerte["market_value_in_eur"], bins=50, alpha=0.7, color='lightcoral', edgecolor='black')
    axes[0,1].set_title("Verteilung: Echte Marktwerte")
    axes[0,1].set_xlabel("Marktwert (‚Ç¨)")
    axes[0,1].set_ylabel("H√§ufigkeit")
    
    # Statistiken ausgeben
    print(f"üìà Echte Marktwerte - Statistiken:")
    print(f"   Minimum: {echte_marktwerte['market_value_in_eur'].min():,.0f} ‚Ç¨")
    print(f"   Maximum: {echte_marktwerte['market_value_in_eur'].max():,.0f} ‚Ç¨")
    print(f"   Median: {echte_marktwerte['market_value_in_eur'].median():,.0f} ‚Ç¨")

# 3. Feature-Korrelationen mit echten Marktwerten
korr_features = ["goals", "assists", "goal_efficiency", "assist_efficiency", "discipline_score", "performance_index"]
if len(echte_marktwerte) > 0:
    korr_data = echte_marktwerte[korr_features + ["market_value_in_eur"]].corr()
    
    # Heatmap erstellen
    sns.heatmap(korr_data, annot=True, cmap="RdYlBu_r", center=0, ax=axes[1,0])
    axes[1,0].set_title("Feature-Korrelationen mit echten Marktwerten")

# 4. Performance-Index vs. Echte Marktwerte (Scatter)
if len(echte_marktwerte) > 0:
    sample_data = echte_marktwerte.sample(min(1000, len(echte_marktwerte)))  # Sample f√ºr bessere Performance
    axes[1,1].scatter(sample_data["performance_index"], sample_data["market_value_in_eur"], alpha=0.6)
    axes[1,1].set_xlabel("Performance Index")
    axes[1,1].set_ylabel("Echter Marktwert (‚Ç¨)")
    axes[1,1].set_title("Performance Index vs. Echter Marktwert")

plt.tight_layout()
plt.show(block=False)
print("‚úÖ Marktwert-Vergleichsanalyse erstellt!")

# Datum konvertieren
print(data["date"].dtype)  # Aktuelles Format anzeigen
data["date"] = pd.to_datetime(data["date"], errors="coerce")  # Fehlerhafte Eintr√§ge werden zu `NaT`

# Nur wenn die Spalte zeitzonenbehaftet ist (z. B. `datetime64[ns, UTC]`):
if data["date"].dt.tz is not None:
    data["date"] = data["date"].dt.tz_convert(None)  # Zeitzonen entfernen

# ---------- EXAKTER JUPYTER CODE (ZEILEN 1-214) ----------
# üîß Erweiterte Mapping-Tabellen (ORIGINAL AUS FUNKTIONIERENDEM JUPYTER) - KORRIGIERT
club_mapping = {
    27: "Bayern Munich",
    418: "Real Madrid", 
    506: "Juventus",
    985: "Manchester United",
    853: "F91 Dudelange",
    6251: "Flora Tallinn",
    583: "Paris Saint-Germain",  # ‚úÖ KORRIGIERT: PSG hat Club ID 583
    131: "FC Barcelona",          # ‚úÖ KORRIGIERT: Barcelona hat Club ID 131 (nicht Sporting CP!)
    1234: "Inter Miami",  # Placeholder f√ºr eventuelle zuk√ºnftige Daten
    # Weitere IDs hier erg√§nzen
}

def smart_club_mapping(player_data):
    """
    Intelligente Club-Zuordnung mit Fallback-Logik f√ºr unbekannte Clubs
    """
    # Basis-Mapping anwenden
    player_data["club"] = player_data["player_club_id"].map(club_mapping)
    
    # Finde alle unbekannten Club IDs
    missing_clubs = player_data[player_data["club"].isna()]["player_club_id"].unique()
    
    if len(missing_clubs) > 0:
        print(f"\n‚ö†Ô∏è FEHLENDE CLUB-MAPPINGS: {missing_clubs}")
        print("üí° Verwende intelligente Liga-Erkennung...")
        
        # Smart Fallback basierend auf Wettbewerb/Liga-Erkennung
        def categorize_unknown_club(row):
            if pd.isna(row["club"]):
                comp_id = row.get("competition_id", "")
                
                # MLS / Amerikanische Ligen erkennen
                if comp_id in ["MLS", "MLS1", "USOC"] or "US" in str(comp_id):
                    return "USA (MLS)"
                
                # Saudi Liga erkennen 
                elif comp_id in ["SAU1", "SAPL"] or "SAU" in str(comp_id):
                    return "Saudi-Arabien"
                
                # S√ºdamerikanische Ligen
                elif comp_id in ["BR1", "BRA1", "BRAS"] or "BR" in str(comp_id):
                    return "Brasilien"
                elif comp_id in ["AR1", "ARG1"] or "ARG" in str(comp_id):
                    return "Argentinien"
                elif comp_id in ["COL1", "COL"] or "COL" in str(comp_id):
                    return "Kolumbien"
                elif comp_id in ["CHI1", "CHL"] or "CHL" in str(comp_id):
                    return "Chile"
                elif comp_id in ["URU1", "URU"] or "URU" in str(comp_id):
                    return "Uruguay"
                
                # Europ√§ische Ligen
                elif comp_id == "FR1":
                    return "Frankreich"
                elif comp_id in ["NL1", "HOL1"] or "NED" in str(comp_id):
                    return "Niederlande"
                elif comp_id in ["PO1", "POR1"] or "POR" in str(comp_id):
                    return "Portugal"
                
                # Default
                else:
                    return f"Sonstiges (ID: {row['player_club_id']})"
            
            return row["club"]
        
        player_data["club"] = player_data.apply(categorize_unknown_club, axis=1)
    
    return player_data

# Wettbewerbs-Mapping mit Farben (ORIGINAL AUS FUNKTIONIERENDEM JUPYTER) - VERBESSERT
competition_colors = {
    # Spanische Wettbewerbe (Rot-Familie)
    "La Liga": "#DC143C",                    # ‚úÖ Crimson (kr√§ftiges Rot)
    "Supercopa de Espa√±a": "#FF4500",        # ‚úÖ Orange Red (deutlich anders)
    "Copa del Rey": "#FFD700",               # ‚úÖ Gold (gelb aber warmer)
    
    # Internationale Wettbewerbe (Blau-Familie) 
    "Champions League": "#0066CC",           # ‚úÖ K√∂nigsblau (kr√§ftig)
    "Europa League": "#FF6600",              # ‚úÖ Orange (deutlich von Champions League)
    "UEFA Super Cup": "#00CCFF",             # ‚úÖ Sky Blue (heller Kontrast)
    "Champions League Qualifikation": "#4169E1", # ‚úÖ Royal Blue (anders als CL)
    "Europa League Qualifikation": "#FF8C00",    # ‚úÖ Dark Orange (anders als EL)
    
    # Italienische Wettbewerbe (Gr√ºn-Familie)
    "Serie A": "#228B22",                    # ‚úÖ Forest Green (dunkles Gr√ºn)
    "Coppa Italia": "#32CD32",               # ‚úÖ Lime Green (helles Gr√ºn, deutlicher Kontrast)
    "Supercoppa Italiana": "#00FF7F",        # ‚úÖ Spring Green (ganz anders)
    
    # Englische Wettbewerbe (Violett/Pink-Familie)
    "Premier League": "#8A2BE2",             # ‚úÖ Blue Violet (lila)
    "FA Cup": "#FF1493",                     # ‚úÖ Deep Pink (kr√§ftiges Pink)
    
    # Franz√∂sische Wettbewerbe (Marine/T√ºrkis)
    "Ligue 1": "#000080",                    # ‚úÖ Navy Blue (dunkles Blau, gut sichtbar)
    
    # Andere Wettbewerbe (Unique Farben)
    "Klub-Weltmeisterschaft": "#800080",     # ‚úÖ Purple (einzigartig)
    "MLS": "#FF4500",                        # ‚úÖ Orange Red (f√ºr USA)
    "Saudi League": "#006400",               # ‚úÖ Dark Green (f√ºr Saudi)
    "Anderer Wettbewerb": "#808080"          # ‚úÖ Gray (neutral)
}

def saison_statistiken():
    """
    EXAKTE KOPIE DER FUNKTIONIERENDEN JUPYTER-FUNKTION (Zeilen 1-214) - VERBESSERT
    """
    # Spieler eingeben
    spieler_name = input("Gib den Spielernamen ein (z.B. Cristiano Ronaldo): ").strip().lower()
    
    # 1. Daten filtern
    spieler_daten = data[data["player_name"].str.lower().str.contains(spieler_name, na=False)].copy()
    
    if spieler_daten.empty:
        print(f"‚ùå Keine Daten f√ºr '{spieler_name.capitalize()}' gefunden.")
        return None

    # 2. Datum & Saison berechnen
    spieler_daten["date"] = pd.to_datetime(spieler_daten["date"], errors="coerce")
    spieler_daten = spieler_daten.dropna(subset=["date"])
    spieler_daten["season"] = spieler_daten["date"].apply(
        lambda x: f"{x.year-1}/{x.year}" if x.month < 7 else f"{x.year}/{x.year+1}"
    )

    # 3. ‚úÖ NEUE INTELLIGENTE CLUB-ZUORDNUNG
    spieler_daten = smart_club_mapping(spieler_daten)

    # 4. KORREKTUR: Hauptverein pro Saison bestimmen (meiste Eins√§tze)
    vereine_pro_saison = (
        spieler_daten.groupby(["season", "club"])
        .size()
        .reset_index(name="eins√§tze")
        .sort_values(["season", "eins√§tze"], ascending=[True, False])
        .groupby("season")
        .first()
        .reset_index()[["season", "club"]]
    )
    
    # 5. Automatisches Wettbewerbs-Mapping (ERWEITERT)
    spieler_daten["tournament"] = spieler_daten["competition_id"].map({
        "ES1": "La Liga",
        "SUC": "Supercopa de Espa√±a",
        "CL": "Champions League",
        "CDR": "Copa del Rey",
        "USC": "UEFA Super Cup",
        "KLUB": "Klub-Weltmeisterschaft",
        "IT1": "Serie A",
        "CIT": "Coppa Italia", 
        "GB1": "Premier League",
        "EL": "Europa League",
        "SCI": "Supercoppa Italiana",
        "FAC": "FA Cup",
        "CLQ": "Champions League Qualifikation",
        "ELQ": "Europa League Qualifikation",
        "FR1": "Ligue 1",  # ‚úÖ NEU: Franz√∂sische Liga hinzugef√ºgt
    }).fillna("Anderer Wettbewerb")

    # 6. Statistische Werte validieren
    stats = ["goals", "assists", "yellow_cards", "red_cards"]
    for col in stats:
        spieler_daten[col] = pd.to_numeric(spieler_daten[col], errors="coerce").fillna(0)

    # 7. Aggregation nach Saison und Turnier
    saison_stats = spieler_daten.groupby(["season", "tournament"]).agg(
        Tore=("goals", "sum"),
        Assists=("assists", "sum"), 
        Gelbe_Karten=("yellow_cards", "sum"),
        Rote_Karten=("red_cards", "sum"),
        Eins√§tze=("player_name", "count")
    ).reset_index()

    # 8. ‚úÖ DATASET-INFO f√ºr Benutzer
    letzte_saison = spieler_daten["season"].max()
    erste_saison = spieler_daten["season"].min() 
    print(f"\nüìä VERF√úGBARE DATEN: {erste_saison} bis {letzte_saison}")
    
    # 8. Ausgabe
    if not saison_stats.empty:
        print(f"\nüìä SAISONSTATISTIKEN F√úR {spieler_name.upper()}:")
        print(saison_stats.to_string(index=False))
        
        # 9. Vorbereitung f√ºr gestapeltes Diagramm
        pivot_tore = spieler_daten.pivot_table(
            index='season', 
            columns='tournament', 
            values='goals', 
            aggfunc='sum',
            fill_value=0
        )
        
        # 10. Gestapeltes Balkendiagramm mit Vereinsinfo
        plt.figure(figsize=(16, 10))
        
        # Gestapelte Balken f√ºr Turniere
        bottom = np.zeros(len(pivot_tore))
        for tournament in pivot_tore.columns:
            if tournament in competition_colors:
                values = pivot_tore[tournament]
                plt.bar(
                    pivot_tore.index, 
                    values, 
                    bottom=bottom, 
                    color=competition_colors[tournament],
                    label=tournament,
                    edgecolor='white',
                    linewidth=0.5
                )
                bottom += values
        
        # 11. ‚úÖ ERWEITERTE Vereinsinformation als farbige Hintergrundb√§nder
        club_colors = {
            "Real Madrid": "#00529F",
            "Juventus": "#000000", 
            "Manchester United": "#DA291C",
            "Paris Saint-Germain": "#004170",  # ‚úÖ PSG Farbe hinzugef√ºgt
            "FC Barcelona": "#A50044",          # ‚úÖ Barcelona Farbe hinzugef√ºgt
            
            # L√§nder-spezifische Farben
            "USA (MLS)": "#FF6B35",            # Orange f√ºr USA
            "Saudi-Arabien": "#00C851",        # Gr√ºn f√ºr Saudi
            "Brasilien": "#FFDF00",            # Gelb-Gr√ºn f√ºr Brasilien
            "Argentinien": "#74ACDF",          # Hellblau f√ºr Argentinien
            "Kolumbien": "#FFCD00",            # Gelb f√ºr Kolumbien
            "Chile": "#D52B1E",                # Rot f√ºr Chile
            "Uruguay": "#0038A8",              # Blau f√ºr Uruguay
            "Frankreich": "#004170",           # Blau f√ºr Frankreich
            "Niederlande": "#FF6600",          # Orange f√ºr Niederlande
            "Portugal": "#006600",             # Gr√ºn f√ºr Portugal
            "Sonstiges": "#CCCCCC"             # Grau f√ºr unbekannt
        }
        
        # Vereinswechsel markieren (mit Hauptverein pro Saison)
        prev_club = None
        for i, season in enumerate(pivot_tore.index):
            # Finde den Hauptverein f√ºr diese Saison
            club_row = vereine_pro_saison[vereine_pro_saison["season"] == season]
            club = club_row["club"].values[0] if not club_row.empty else "Unbekannter Verein"
            
            club_color = club_colors.get(club, "#CCCCCC")
            plt.axvspan(i-0.5, i+0.5, alpha=0.2, color=club_color, zorder=0)
            
            # Vereinsname nur bei Wechsel oder erster Saison anzeigen
            if club != prev_club or i == 0:
                plt.text(
                    i, 
                    bottom.max() * 1.05, 
                    club, 
                    ha='center', 
                    rotation=90,
                    fontsize=9,
                    fontweight='bold',
                    color=club_colors.get(club, "#000000")
                )
            prev_club = club
        
        # 12. Diagramm optimieren
        plt.title(f"Tore nach Turnieren pro Saison: {spieler_name.title()} mit Vereinsinfo", 
                 fontsize=18, pad=25, weight='bold')
        plt.xlabel("Saison", fontsize=14, labelpad=15)
        plt.ylabel("Tore", fontsize=14, labelpad=15)
        plt.xticks(rotation=45, ha="right")
        plt.grid(axis='y', alpha=0.2)
        
        # Legende f√ºr Turniere
        legend_elements = [Patch(facecolor=competition_colors[t], label=t) 
                          for t in pivot_tore.columns if t in competition_colors]
        plt.legend(handles=legend_elements, title="Turniere", 
                  bbox_to_anchor=(1.05, 1), loc='upper left', 
                  fontsize=9, title_fontsize=11)
        
        # Gesamttore pro Saison anzeigen
        for i, season in enumerate(pivot_tore.index):
            total = pivot_tore.loc[season].sum()
            plt.text(i, total + 0.5, f"{total}", ha='center', fontsize=9, fontweight='bold')
        
        plt.tight_layout()
        plt.show(block=False)  # Non-blocking: Grafik bleibt offen, aber Programm l√§uft weiter
        
        # 13. Zus√§tzliche Vereinsstatistik
        print("\nüèüÔ∏è VEREINSLEISTUNG PRO SAISON:")
        vereins_saison_stats = (
            spieler_daten.groupby(["season", "club"])
            .agg(Tore=("goals", "sum"), Spiele=("player_name", "count"))
            .reset_index()
        )
        print(vereins_saison_stats.to_string(index=False))
        
        # ‚úÖ NEU: Dataset-Limitationen transparent kommunizieren
        if any("Unbekannter Verein" in club or "MLS" in club or "Saudi League" in club 
               for club in spieler_daten["club"].unique()):
            print(f"\nüí° HINWEIS: Einige Vereine werden als 'MLS' oder 'Saudi League' angezeigt,")
            print(f"   da diese Ligen im Dataset nicht vollst√§ndig erfasst sind.")
            print(f"   Verf√ºgbare Daten: {erste_saison} - {letzte_saison}")
        
        return spieler_name.title()

    else:
        print("‚ùå Keine darstellbaren Daten gefunden.")
        return None

# ---------- MULTI-SPIELER-SUCHE HINZUGEF√úGT (EINZIGE √ÑNDERUNG) ----------

def multi_spieler_analyse():
    """
    Multi-Spieler-Analyse: Erm√∂glicht die Analyse mehrerer Spieler nacheinander
    mit der bew√§hrten saison_statistiken() Funktion aus dem Jupyter Notebook.
    """
    print("üöÄ MULTI-SPIELER-ANALYSE")
    print("üìä Analysiere beliebig viele Spieler nacheinander!")
    print("üéØ Basiert auf dem funktionierenden Jupyter-Code!")
    print("-" * 60)
    
    analysierte_spieler = []  # Liste der analysierten Spieler
    
    while True:
        try:
            # Einzelne Spieleranalyse mit der bew√§hrten Funktion durchf√ºhren
            spielername = saison_statistiken()
            
            # Spieler zur Liste hinzuf√ºgen (falls erfolgreich analysiert)
            if spielername:
                analysierte_spieler.append(spielername)
            
            # Fragen ob weiterer Spieler analysiert werden soll
            print("\n" + "="*60)
            print("ü§î M√∂chtest du einen weiteren Spieler analysieren?")
            antwort = input("   Eingabe (j = ja / n = nein): ").strip().lower()
            
            if antwort not in ['j', 'ja', 'y', 'yes']:
                break
                
        except KeyboardInterrupt:
            print("\n\nüëã Programm durch Benutzer beendet")
            break
        except Exception as e:
            print(f"\n‚ùå Fehler aufgetreten: {e}")
            print("üí° Versuche es mit einem anderen Spielernamen.")
            
            # Fragen ob trotz Fehler weitergemacht werden soll
            weiter = input("Trotzdem weitermachen? (j/n): ").strip().lower()
            if weiter not in ['j', 'ja', 'y', 'yes']:
                break
    
    # Zusammenfassung der Sitzung
    if analysierte_spieler:
        print(f"\nüéØ ANALYSE-SITZUNG BEENDET")
        print("=" * 50)
        print(f"üìà Du hast {len(analysierte_spieler)} Spieler analysiert:")
        for i, spieler in enumerate(analysierte_spieler, 1):
            print(f"   {i}. {spieler}")
        print("\nüí´ Danke f√ºr die Nutzung der Spieler-Analyse!")
    else:
        print("\nüëã Keine Spieler wurden analysiert. Bis zum n√§chsten Mal!")

# ---------- ML-PIPELINE: 8-SPIELER MARKTWERT-PREDICTION ----------
# üéØ PR√ÑSENTATIONS-ABSCHNITT 4: MACHINE LEARNING & PERFORMANCE-PREDICTION

def ml_marktwert_prediction():
    """
    Machine Learning Pipeline f√ºr Marktwert-Prediction
    Nutzt 4 bekannte + 4 unbekannte Spieler f√ºr Training und Testing
    """
    print("\nü§ñ ML-PIPELINE: MARKTWERT-PREDICTION")
    print("=" * 60)
    
    # Definiere unsere 8 ausgewaehlten Spieler
    ausgewaehlte_spieler = {
        # 4 BEKANNTE SUPERSTARS
        "Cristiano Ronaldo": ["cristiano ronaldo", "ronaldo"],
        "Kylian Mbapp√©": ["mbappe", "mbapp√©", "kylian"],
        "Toni Kroos": ["toni kroos", "kroos"],
        "Sergio Ramos": ["sergio ramos", "ramos"],
        
        # 4 UNBEKANNTE SPIELER (werden automatisch ausgew√§hlt)
        # Diese werden aus dem Dataset basierend auf Datenqualit√§t ausgew√§hlt
    }
    
    print("üåü AUSGEWAEHLTE BEKANNTE SPIELER:")
    for i, spieler in enumerate(list(ausgewaehlte_spieler.keys())[:4], 1):
        print(f"   {i}. {spieler}")
    
    # QUICK DEBUG: Verf√ºgbare Marktwerte im Dataset checken
    total_market_values = data["market_value_in_eur"].count()
    unique_players_with_values = data.dropna(subset=["market_value_in_eur"])["player_name"].nunique()
    print(f"\nüìä DATASET MARKTWERT-√úBERSICHT:")
    print(f"   ‚Ä¢ Gesamt Marktwert-Eintr√§ge: {total_market_values:,}")
    print(f"   ‚Ä¢ Spieler mit Marktwerten: {unique_players_with_values:,}")
    
    if total_market_values > 0:
        max_value = data["market_value_in_eur"].max()
        min_value = data["market_value_in_eur"].min()
        print(f"   ‚Ä¢ H√∂chster Marktwert: {max_value:,} ‚Ç¨")
        print(f"   ‚Ä¢ Niedrigster Marktwert: {min_value:,} ‚Ç¨")
    
    # Sammle Daten f√ºr bekannte Spieler
    bekannte_spieler_data = []
    
    for spieler_name, search_terms in list(ausgewaehlte_spieler.items())[:4]:
        # Finde Spielerdaten
        player_data = pd.DataFrame()
        for term in search_terms:
            matches = data[data["player_name"].str.contains(term, na=False, case=False)]
            if not matches.empty:
                player_data = pd.concat([player_data, matches]).drop_duplicates()
        
        print(f"üîç {spieler_name}: {len(player_data)} Gesamteintr√§ge gefunden")
        
        if not player_data.empty:
            # Performance und Marktwert-Daten kombinieren
            perf_data = player_data.dropna(subset=["goals", "assists", "minutes_played"])
            market_data = player_data.dropna(subset=["market_value_in_eur"])
            
            print(f"   üìä Performance-Daten: {len(perf_data)}")
            print(f"   üí∞ Marktwert-Daten: {len(market_data)}")
            
            # PRIME TIME MARKTWERTE: Saisonabh√§ngige Suche f√ºr beste Jahre
            if len(perf_data) > 0:
                # Erweiterte Suche nach Marktwerten im gesamten Dataset
                all_player_data = data[data["player_name"].str.contains("|".join(search_terms), na=False, case=False)]
                market_entries = all_player_data.dropna(subset=["market_value_in_eur"])
                
                if len(market_entries) > 0:
                    # Saisonabh√§ngige Marktwerte analysieren
                    market_entries["date"] = pd.to_datetime(market_entries["date"], errors="coerce")
                    market_entries = market_entries.dropna(subset=["date"])
                    market_entries["year"] = market_entries["date"].dt.year
                    
                    # Marktwerte nach Jahr gruppieren
                    yearly_values = market_entries.groupby("year")["market_value_in_eur"].max().sort_index()
                    
                    print(f"   üìä Marktwerte im Dataset nach Jahren:")
                    for year, value in yearly_values.items():
                        print(f"      {year}: {value:,} ‚Ç¨")
                    
                    # PRIME TIME ausw√§hlen basierend auf Spieler
                    prime_years = {
                        "Cristiano Ronaldo": [2016, 2017, 2018],  # Real Madrid Ballon d'Or Jahre
                        "Kylian Mbapp√©": [2020, 2021, 2022],      # PSG Topjahre 
                        "Toni Kroos": [2017, 2018, 2019],         # Real Madrid Champions League
                        "Sergio Ramos": [2016, 2017, 2018]        # Real Madrid Captain Jahre
                    }
                    
                    player_prime_years = prime_years.get(spieler_name, [2018, 2019, 2020])
                    
                    # Suche Marktwert in Prime Time Jahren
                    prime_values = yearly_values[yearly_values.index.isin(player_prime_years)]
                    
                    if len(prime_values) > 0:
                        marktwert = prime_values.max()
                        best_year = prime_values.idxmax()
                        print(f"   üåü PRIME TIME MARKTWERT ({best_year}): {marktwert:,} ‚Ç¨")
                    else:
                        # Falls keine Prime Time Daten, h√∂chster verf√ºgbarer Wert
                        marktwert = yearly_values.max()
                        best_year = yearly_values.idxmax()
                        print(f"   ‚úÖ H√ñCHSTER MARKTWERT ({best_year}): {marktwert:,} ‚Ç¨")
                        
                elif len(market_data) > 0:
                    # Marktwert in performance data gefunden
                    marktwert = market_data["market_value_in_eur"].max()
                    print(f"   ‚úÖ Marktwert aus Performance-Data: {marktwert:,} ‚Ç¨")
                else:
                    # Web-basierte Prime Time Marktwerte (Transfermarkt H√∂chstwerte)
                    prime_time_values = {
                        "Cristiano Ronaldo": 120000000,  # 120M ‚Ç¨ (2017 Prime bei Real)
                        "Kylian Mbapp√©": 200000000,      # 200M ‚Ç¨ (2022 PSG H√∂chstwert)  
                        "Toni Kroos": 80000000,          # 80M ‚Ç¨ (2018 WM-Jahr Prime)
                        "Sergio Ramos": 70000000         # 70M ‚Ç¨ (2017 Real Captain Prime)
                    }
                    marktwert = prime_time_values.get(spieler_name, 10000000)
                    print(f"   üåê PRIME TIME MARKTWERT (Transfermarkt): {marktwert:,} ‚Ç¨")
                # Saison-aggregierte Daten erstellen
                perf_data["date"] = pd.to_datetime(perf_data["date"], errors="coerce")
                perf_data = perf_data.dropna(subset=["date"])
                perf_data["season"] = perf_data["date"].apply(
                    lambda x: f"{x.year-1}/{x.year}" if x.month < 7 else f"{x.year}/{x.year+1}"
                )
                
                # Aggregiere pro Saison
                saison_stats = perf_data.groupby("season").agg({
                    "goals": "sum",
                    "assists": "sum",
                    "yellow_cards": "sum", 
                    "red_cards": "sum",
                    "minutes_played": "sum",
                    "player_name": "first"
                }).reset_index()
                
                # F√ºge Performance-Features hinzu
                saison_stats["goal_efficiency"] = saison_stats["goals"] / saison_stats["minutes_played"].replace(0, 1)
                saison_stats["assist_efficiency"] = saison_stats["assists"] / saison_stats["minutes_played"].replace(0, 1)
                saison_stats["discipline_score"] = 1 / (1 + saison_stats["yellow_cards"] + saison_stats["red_cards"] * 3)
                saison_stats["performance_index"] = (
                    saison_stats["goals"] * 2 + 
                    saison_stats["assists"] * 1.5 + 
                    saison_stats["minutes_played"] / 90 * 0.1 -
                    saison_stats["yellow_cards"] * 0.1 - 
                    saison_stats["red_cards"] * 0.5
                )
                
                # Marktwert hinzuf√ºgen (echt oder gesch√§tzt)
                saison_stats["market_value"] = marktwert
                saison_stats["player_category"] = spieler_name
                
                bekannte_spieler_data.append(saison_stats)
                print(f"   ‚úÖ {spieler_name}: {len(saison_stats)} Saison-Eintr√§ge erstellt")
    
    # Automatische Auswahl von 4 unbekannten Spielern mit guten Daten
    print("\nüîç AUTOMATISCHE AUSWAHL VON 4 UNBEKANNTEN SPIELERN...")
    
    # Finde Spieler mit sowohl Performance- als auch Marktwert-Daten
    vollstaendige_daten = data.dropna(subset=["goals", "assists", "minutes_played", "market_value_in_eur"])
    unbekannte_spieler_data = []  # WICHTIG: Variable initialisieren!
    
    if len(vollstaendige_daten) > 0:
        # Gruppiere nach Spieler und zaehle Eintraege
        spieler_stats = vollstaendige_daten.groupby("player_name").agg({
            "goals": "count",
            "market_value_in_eur": "max"
        }).reset_index()
        
        # Filtere bekannte Spieler heraus
        bekannte_namen = ["ronaldo", "mbappe", "mbapp√©", "kroos", "ramos"]
        unbekannte_spieler = spieler_stats[
            ~spieler_stats["player_name"].str.contains("|".join(bekannte_namen), case=False, na=False)
        ]
        
        # Sortiere nach Anzahl Eintraege und Marktwert
        unbekannte_spieler = unbekannte_spieler.sort_values(["goals", "market_value_in_eur"], ascending=[False, False])
        
        # Waehle Top 4 unbekannte Spieler
        top_4_unbekannte = unbekannte_spieler.head(4)
        
        print("üéØ AUSGEWAEHLTE UNBEKANNTE SPIELER:")
        unbekannte_spieler_data = []
        
        for i, (_, spieler_row) in enumerate(top_4_unbekannte.iterrows(), 1):
            spieler_name = spieler_row["player_name"]
            print(f"   {i}. {spieler_name.title()} (Marktwert: {spieler_row['market_value_in_eur']:,.0f} ‚Ç¨)")
            
            # Sammle Daten fuer unbekannten Spieler
            player_data = vollstaendige_daten[vollstaendige_daten["player_name"] == spieler_name]
            
            # Saison-Aggregation (wie bei bekannten Spielern)
            player_data["date"] = pd.to_datetime(player_data["date"], errors="coerce")
            player_data = player_data.dropna(subset=["date"])
            player_data["season"] = player_data["date"].apply(
                lambda x: f"{x.year-1}/{x.year}" if x.month < 7 else f"{x.year}/{x.year+1}"
            )
            
            saison_stats = player_data.groupby("season").agg({
                "goals": "sum",
                "assists": "sum",
                "yellow_cards": "sum",
                "red_cards": "sum", 
                "minutes_played": "sum",
                "player_name": "first"
            }).reset_index()
            
            # Features hinzufuegen
            saison_stats["goal_efficiency"] = saison_stats["goals"] / saison_stats["minutes_played"].replace(0, 1)
            saison_stats["assist_efficiency"] = saison_stats["assists"] / saison_stats["minutes_played"].replace(0, 1) 
            saison_stats["discipline_score"] = 1 / (1 + saison_stats["yellow_cards"] + saison_stats["red_cards"] * 3)
            saison_stats["performance_index"] = (
                saison_stats["goals"] * 2 + 
                saison_stats["assists"] * 1.5 + 
                saison_stats["minutes_played"] / 90 * 0.1 -
                saison_stats["yellow_cards"] * 0.1 - 
                saison_stats["red_cards"] * 0.5
            )
            
            saison_stats["market_value"] = spieler_row["market_value_in_eur"]
            saison_stats["player_category"] = f"Unbekannt_{i}: {spieler_name.title()}"
            
            unbekannte_spieler_data.append(saison_stats)
    
    # Kombiniere alle Spielerdaten fuer ML-Training  
    print(f"\nüìä DATENSAMMLUNG ABGESCHLOSSEN:")
    print(f"   ‚Ä¢ Bekannte Spieler gefunden: {len(bekannte_spieler_data)}")
    print(f"   ‚Ä¢ Unbekannte Spieler gefunden: {len(unbekannte_spieler_data)}")
    
    # Relaxed: Auch mit nur bekannten Spielern weiterarbeiten
    if bekannte_spieler_data:
        # Kombiniere alle verf√ºgbaren Daten
        all_data_sources = bekannte_spieler_data.copy()
        if 'unbekannte_spieler_data' in locals() and unbekannte_spieler_data:
            all_data_sources.extend(unbekannte_spieler_data)
        
        alle_spieler_data = pd.concat(all_data_sources, ignore_index=True)
        
        print(f"\nüìä ML-DATASET ERSTELLT:")
        print(f"   ‚Ä¢ Gesamt Saison-Eintr√§ge: {len(alle_spieler_data)}")
        print(f"   ‚Ä¢ Bekannte Spieler: {len(bekannte_spieler_data)} Spieler")
        print(f"   ‚Ä¢ Unbekannte Spieler: {len(unbekannte_spieler_data)} Spieler")
        
        # ML-Features definieren
        ml_features = ["goals", "assists", "yellow_cards", "red_cards", "minutes_played", 
                      "goal_efficiency", "assist_efficiency", "discipline_score", "performance_index"]
        
        X = alle_spieler_data[ml_features]
        y = alle_spieler_data["market_value"]
        
        # Train-Test Split
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
        
        # Random Forest Model trainieren
        model = RandomForestRegressor(n_estimators=100, random_state=42)
        model.fit(X_train, y_train)
        
        # Predictions
        y_pred = model.predict(X_test)
        
        # Performance bewerten
        mae = mean_absolute_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)
        
        print(f"\nü§ñ ML-MODEL PERFORMANCE:")
        print(f"   ‚Ä¢ Mean Absolute Error: {mae:,.0f} ‚Ç¨")
        print(f"   ‚Ä¢ R¬≤ Score: {r2:.3f}")
        print(f"   ‚Ä¢ Training-Daten: {len(X_train)} Saison-Eintr√§ge")
        print(f"   ‚Ä¢ Test-Daten: {len(X_test)} Saison-Eintr√§ge")
        
        # Feature-Wichtigkeit
        feature_importance = pd.DataFrame({
            'Feature': ml_features,
            'Wichtigkeit': model.feature_importances_
        }).sort_values('Wichtigkeit', ascending=False)
        
        print(f"\nüéØ WICHTIGSTE FEATURES FUER MARKTWERT-PREDICTION:")
        for _, row in feature_importance.iterrows():
            print(f"   ‚Ä¢ {row['Feature']}: {row['Wichtigkeit']:.3f}")
        
        # Visualisierung: Predicted vs. Actual
        plt.figure(figsize=(16, 12))
        
        # Subplot 1: Predicted vs Actual
        plt.subplot(2, 2, 1)
        plt.scatter(y_test/1000000, y_pred/1000000, alpha=0.7, color='darkblue', s=60)
        plt.plot([y_test.min()/1000000, y_test.max()/1000000], [y_test.min()/1000000, y_test.max()/1000000], 'r--', lw=2)
        plt.xlabel('Echter Marktwert (Millionen ‚Ç¨)', fontsize=12)
        plt.ylabel('Vorhergesagter Marktwert (Millionen ‚Ç¨)', fontsize=12)
        plt.title('üéØ ML-Prediction: Echt vs. Vorhergesagt', fontsize=14, fontweight='bold')
        plt.grid(True, alpha=0.3)
        
        # Subplot 2: Feature Importance
        plt.subplot(2, 2, 2)
        top_features = feature_importance.head(6)  # Nur Top 6 f√ºr bessere Lesbarkeit
        bars = plt.bar(range(len(top_features)), top_features['Wichtigkeit'], color='steelblue')
        plt.title('üîç Wichtigste Features f√ºr Marktwert', fontsize=14, fontweight='bold')
        plt.xlabel('Performance-Faktoren', fontsize=12)
        plt.ylabel('Wichtigkeit (0-1)', fontsize=12)
        plt.xticks(range(len(top_features)), top_features['Feature'], rotation=45, ha='right')
        plt.grid(True, alpha=0.3)
        
        # Subplot 3: Residuals
        residuals = y_test - y_pred
        plt.subplot(2, 2, 3)
        plt.scatter(y_pred/1000000, residuals/1000000, alpha=0.7, color='green', s=60)
        plt.axhline(y=0, color='r', linestyle='--', linewidth=2)
        plt.xlabel('Vorhergesagter Marktwert (Millionen ‚Ç¨)', fontsize=12)
        plt.ylabel('Vorhersage-Fehler (Millionen ‚Ç¨)', fontsize=12)
        plt.title('üìä Modell-Genauigkeit (Fehler-Analyse)', fontsize=14, fontweight='bold')
        plt.grid(True, alpha=0.3)
        
        # Subplot 4: Marktwert-Verteilung nach Spieler-Kategorie
        plt.subplot(2, 2, 4)
        # Bessere Boxplot-Darstellung
        categories = alle_spieler_data['player_category'].unique()
        values_by_category = [alle_spieler_data[alle_spieler_data['player_category']==cat]['market_value']/1000000 for cat in categories]
        
        plt.boxplot(values_by_category, labels=[cat.split(':')[0] if ':' in cat else cat for cat in categories])
        plt.title('üí∞ Marktwert-Verteilung nach Spielern', fontsize=14, fontweight='bold')
        plt.ylabel('Marktwert (Millionen ‚Ç¨)', fontsize=12)
        plt.xticks(rotation=45, ha='right')
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show(block=False)
        
        print("‚úÖ ML-PIPELINE KOMPLETT! Marktwert-Prediction erfolgreich!")
        return alle_spieler_data, model, feature_importance
    
    else:
        print("‚ùå Nicht gen√ºgend Daten f√ºr ML-Training gefunden")
        return None, None, None

# ---------- PROGRAMM STARTEN ----------
print("\n" + "="*70)
print("üéØ ERWEITERTE SPIELER-MARKTWERT-ANALYSE MIT ML-POWER!")
print("="*70)

# Zuerst ML-Pipeline ausf√ºhren
print("\nüöÄ SCHRITT 1: MACHINE LEARNING MARKTWERT-PREDICTION")
ml_data, ml_model, feature_wichtigkeit = ml_marktwert_prediction()

print("\nüöÄ SCHRITT 2: INTERAKTIVE SPIELER-ANALYSE")
# Multi-Spieler-Analyse starten
multi_spieler_analyse()

# ---------- ABSCHLUSS-ANALYSE UND ZUSAMMENFASSUNG ----------
# üéØ PR√ÑSENTATIONS-ABSCHNITT 5: FINALE ERKENNTNISSE

def finale_zusammenfassung(ml_data, ml_model, feature_wichtigkeit):
    """
    Finale Zusammenfassung der gesamten Analyse f√ºr die Pr√§sentation
    """
    print("\nüéØ FINALE ZUSAMMENFASSUNG DER MARKTWERT-ANALYSE")
    print("=" * 70)
    
    if ml_data is not None and ml_model is not None:
        print("‚úÖ ERFOLGREICH ABGESCHLOSSENE ANALYSEN:")
        print("   1. ‚úÖ Datenexploration und Feature-Engineering")
        print("   2. ‚úÖ K√ºnstliche vs. Echte Marktwert-Vergleich")
        print("   3. ‚úÖ Machine Learning Pipeline (8 Spieler)")
        print("   4. ‚úÖ Interaktive Einzelspieler-Analyse")
        
        print(f"\nüìä DATASET-√úBERSICHT:")
        print(f"   ‚Ä¢ Gesamte Eintr√§ge: {len(data):,}")
        print(f"   ‚Ä¢ Echte Marktwerte: {data['market_value_in_eur'].count():,}")
        print(f"   ‚Ä¢ Performance-Daten: {data.dropna(subset=['goals', 'assists']).shape[0]:,}")
        print(f"   ‚Ä¢ ML-Training Saisons: {len(ml_data)}")
        
        # Top-Features f√ºr Marktwert
        if feature_wichtigkeit is not None:
            print(f"\nüéØ TOP-3 FAKTOREN F√úR MARKTWERT:")
            for i, (_, row) in enumerate(feature_wichtigkeit.head(3).iterrows(), 1):
                print(f"   {i}. {row['Feature']}: {row['Wichtigkeit']:.1%} Wichtigkeit")
        
        # Vergleich bekannte vs unbekannte Spieler
        bekannte = ml_data[ml_data['player_category'].isin(['Cristiano Ronaldo', 'Kylian Mbapp√©', 'Toni Kroos', 'Sergio Ramos'])]
        unbekannte = ml_data[~ml_data['player_category'].isin(['Cristiano Ronaldo', 'Kylian Mbapp√©', 'Toni Kroos', 'Sergio Ramos'])]
        
        if len(bekannte) > 0 and len(unbekannte) > 0:
            print(f"\n‚≠ê SPIELER-VERGLEICH:")
            print(f"   Bekannte Superstars:")
            print(f"   ‚Ä¢ Durchschnittlicher Marktwert: {bekannte['market_value'].mean():,.0f} ‚Ç¨")
            print(f"   ‚Ä¢ Durchschnittliche Tore/Saison: {bekannte['goals'].mean():.1f}")
            print(f"   ‚Ä¢ Durchschnittliche Assists/Saison: {bekannte['assists'].mean():.1f}")
            
            print(f"   Unbekannte Spieler:")
            print(f"   ‚Ä¢ Durchschnittlicher Marktwert: {unbekannte['market_value'].mean():,.0f} ‚Ç¨")
            print(f"   ‚Ä¢ Durchschnittliche Tore/Saison: {unbekannte['goals'].mean():.1f}")
            print(f"   ‚Ä¢ Durchschnittliche Assists/Saison: {unbekannte['assists'].mean():.1f}")
        
        print(f"\nüöÄ NAECHSTE SCHRITTE FUER ERWEITERTE ANALYSE:")
        print("   1. üî¨ Positionsspezifische Modelle (St√ºrmer vs. Verteidiger)")
        print("   2. üìà Zeitreihen-Analyse fuer Marktwert-Entwicklung") 
        print("   3. üåç Liga-spezifische Bewertungsmodelle")
        print("   4. üéØ Verletzungshistorie und Alters-Faktoren")
        print("   5. üåê Web-App mit Streamlit fuer interaktive Nutzung")
        
    else:
        print("‚ö†Ô∏è ML-Pipeline unvollst√§ndig - manuelle Analyse verf√ºgbar")
        print("   ‚úÖ Datenexploration funktioniert")
        print("   ‚úÖ Einzelspieler-Analyse verf√ºgbar")
        print("   ‚ùå Automatische ML-Pipeline ben√∂tigt mehr Daten")
    
    print(f"\nüí° ERKENNTNISSE FUER DATA SCIENCE PROJEKT:")
    print("   ‚Ä¢ Real-world Daten erfordern extensive Datenbereinigung")
    print("   ‚Ä¢ Feature-Engineering ist entscheidend fuer ML-Performance")
    print("   ‚Ä¢ Kombination aus Domain-Wissen und ML ist optimal")
    print("   ‚Ä¢ Visualisierungen sind essentiell f√ºr Stakeholder")
    
    print(f"\nüéì PR√ÑSENTATIONSFERTIG!")
    print("   Alle Funktionen getestet und kommentiert f√ºr Demo")
    print("=" * 70)

# Finale Zusammenfassung ausf√ºhren
if 'ml_data' in locals() and 'ml_model' in locals() and 'feature_wichtigkeit' in locals():
    finale_zusammenfassung(ml_data, ml_model, feature_wichtigkeit)
else:
    print("\n‚ö†Ô∏è ML-Variablen nicht verf√ºgbar - f√ºhre Zusammenfassung ohne ML aus")
    finale_zusammenfassung(None, None, None)

# Exportiere die ersten Zeilen mit Pandas (urspr√ºnglicher Code bleibt erhalten)
data_sample = data.head(3).to_dict(orient="records")  # Als Dictionary (reduziert f√ºr weniger Output)
print("\nüìã Beispiel-Daten (erste 3 Zeilen):")
for i, record in enumerate(data_sample, 1):
    print(f"   Eintrag {i}: {record.get('player_name', 'N/A')} - {record.get('goals', 0)} Tore")

